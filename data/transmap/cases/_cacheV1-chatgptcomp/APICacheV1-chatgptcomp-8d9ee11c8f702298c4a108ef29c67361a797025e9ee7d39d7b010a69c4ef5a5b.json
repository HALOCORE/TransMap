{"func_id": "chatgptcomp", "params": {"messages": [{"role": "system", "content": "\nYou are a helpful assistant that translates Python code into JavaScript code.\nFor user requests, you output the code directly without explanations, and always in the same format.\nYou should ALWAYS output best-effort translation, even if you are provided partial code, modules, or code with dependencies.\nFor omitted part of the code in the source '...', you should also use '...' to denote the omitted part in the translation.\n"}, {"role": "user", "content": "**Translate this code from Python into Modern JavaScript:**\n### Python\n\n```python\nprint(\"Hello World\")\n```\n"}, {"role": "assistant", "content": "### JavaScript\n\n```javascript\n\"use strict\";\n\nconsole.log(\"Hello World\");\n```\n"}, {"role": "user", "content": "**Translate this code from Python into Modern JavaScript:**\n### Python\n\n```python\n    # TRANSLATION NOTE: this function is inside a class `ParserBase.`\n    # Internal -- parse declaration (for use by subclasses).\n    def parse_declaration(self, i):\n        # This is some sort of declaration; in \"HTML as\n        # deployed,\" this should only be the document type\n        # declaration (\"<!DOCTYPE html...>\").\n        # ISO 8879:1986, however, has more complex\n        # declaration syntax for elements in <!...>, including:\n        # --comment--\n        # [marked section]\n        # name in the following list: ENTITY, DOCTYPE, ELEMENT,\n        # ATTLIST, NOTATION, SHORTREF, USEMAP,\n        # LINKTYPE, LINK, IDLINK, USELINK, SYSTEM\n        rawdata = self.rawdata\n        j = i + 2\n        assert rawdata[i:j] == \"<!\", \"unexpected call to parse_declaration\"\n        if rawdata[j:j+1] == \">\":\n            # the empty comment <!>\n            return j + 1\n        if rawdata[j:j+1] in (\"-\", \"\"):\n            # Start of comment followed by buffer boundary,\n            # or just a buffer boundary.\n            return -1\n        # A simple, practical version could look like: ((name|stringlit) S*) + '>'\n        n = len(rawdata)\n        if rawdata[j:j+2] == '--': #comment\n            # Locate --.*-- as the body of the comment\n            return self.parse_comment(i)\n        elif rawdata[j] == '[': #marked section\n            # Locate [statusWord [...arbitrary SGML...]] as the body of the marked section\n            # Where statusWord is one of TEMP, CDATA, IGNORE, INCLUDE, RCDATA\n            # Note that this is extended by Microsoft Office \"Save as Web\" function\n            # to include [if...] and [endif].\n            return self.parse_marked_section(i)\n        else: #all other declaration elements\n            decltype, j = self._scan_name(j, i)\n        if j < 0:\n            return j\n        if decltype == \"doctype\":\n            self._decl_otherchars = ''\n        while j < n:\n            c = rawdata[j]\n            if c == \">\":\n                # end of declaration syntax\n                data = rawdata[i+2:j]\n                if decltype == \"doctype\":\n                    self.handle_decl(data)\n                else:\n                    # According to the HTML5 specs sections \"8.2.4.44 Bogus\n                    # comment state\" and \"8.2.4.45 Markup declaration open\n                    # state\", a comment token should be emitted.\n                    # Calling unknown_decl provides more flexibility though.\n                    self.unknown_decl(data)\n                return j + 1\n            if c in \"\\\"'\":\n                m = _declstringlit_match(rawdata, j)\n                if not m:\n                    return -1 # incomplete\n                j = m.end()\n            elif c in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                name, j = self._scan_name(j, i)\n            elif c in self._decl_otherchars:\n                j = j + 1\n            elif c == \"[\":\n                # this could be handled in a separate doctype parser\n                if decltype == \"doctype\":\n                    j = self._parse_doctype_subset(j + 1, i)\n                elif decltype in {\"attlist\", \"linktype\", \"link\", \"element\"}:\n                    # must tolerate []'d groups in a content model in an element declaration\n                    # also in data attribute specifications of attlist declaration\n                    # also link type declaration subsets in linktype declarations\n                    # also link attribute specification lists in link declarations\n                    raise AssertionError(\"unsupported '[' char in %s declaration\" % decltype)\n                else:\n                    raise AssertionError(\"unexpected '[' char in declaration\")\n            else:\n                raise AssertionError(\"unexpected %r char in declaration\" % rawdata[j])\n            if j < 0:\n                return j\n        return -1 # incomplete\n\n```\n"}], "max_length": 3095, "stop": "", "temp": 0, "stream": false, "engine": "gpt-3.5-turbo"}, "ret_val": {"completion": {"choices": [{"finish_reason": "stop", "index": 0, "message": {"content": "```javascript\n// TRANSLATION NOTE: this function is inside a class `ParserBase.`\n// Internal -- parse declaration (for use by subclasses).\nparse_declaration(i) {\n    // This is some sort of declaration; in \"HTML as\n    // deployed,\" this should only be the document type\n    // declaration (\"<!DOCTYPE html...>\").\n    // ISO 8879:1986, however, has more complex\n    // declaration syntax for elements in <!...>, including:\n    // --comment--\n    // [marked section]\n    // name in the following list: ENTITY, DOCTYPE, ELEMENT,\n    // ATTLIST, NOTATION, SHORTREF, USEMAP,\n    // LINKTYPE, LINK, IDLINK, USELINK, SYSTEM\n    const rawdata = this.rawdata;\n    let j = i + 2;\n    assert(rawdata.slice(i, j) === \"<!\", \"unexpected call to parse_declaration\");\n    if (rawdata.slice(j, j + 1) === \">\") {\n        // the empty comment <!>\n        return j + 1;\n    }\n    if (rawdata.slice(j, j + 1) in [\"-\", \"\"]) {\n        // Start of comment followed by buffer boundary,\n        // or just a buffer boundary.\n        return -1;\n    }\n    // A simple, practical version could look like: ((name|stringlit) S*) + '>'\n    const n = rawdata.length;\n    if (rawdata.slice(j, j + 2) === \"--\") { //comment\n        // Locate --.*-- as the body of the comment\n        return this.parse_comment(i);\n    } else if (rawdata[j] === \"[\") { //marked section\n        // Locate [statusWord [...arbitrary SGML...]] as the body of the marked section\n        // Where statusWord is one of TEMP, CDATA, IGNORE, INCLUDE, RCDATA\n        // Note that this is extended by Microsoft Office \"Save as Web\" function\n        // to include [if...] and [endif].\n        return this.parse_marked_section(i);\n    } else { //all other declaration elements\n        const [decltype, j] = this._scan_name(j, i);\n    }\n    if (j < 0) {\n        return j;\n    }\n    if (decltype === \"doctype\") {\n        this._decl_otherchars = '';\n    }\n    while (j < n) {\n        const c = rawdata[j];\n        if (c === \">\") {\n            // end of declaration syntax\n            const data = rawdata.slice(i + 2, j);\n            if (decltype === \"doctype\") {\n                this.handle_decl(data);\n            } else {\n                // According to the HTML5 specs sections \"8.2.4.44 Bogus\n                // comment state\" and \"8.2.4.45 Markup declaration open\n                // state\", a comment token should be emitted.\n                // Calling unknown_decl provides more flexibility though.\n                this.unknown_decl(data);\n            }\n            return j + 1;\n        }\n        if (c in [\"\\\"\", \"'\"]) {\n            const m = _declstringlit_match(rawdata, j);\n            if (!m) {\n                return -1; // incomplete\n            }\n            j = m.end();\n        } else if (c in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n            const [name, j] = this._scan_name(j, i);\n        } else if (this._decl_otherchars.includes(c)) {\n            j = j + 1;\n        } else if (c === \"[\") {\n            // this could be handled in a separate doctype parser\n            if (decltype === \"doctype\") {\n                j = this._parse_doctype_subset(j + 1, i);\n            } else if (new Set([\"attlist\", \"linktype\", \"link\", \"element\"]).has(decltype)) {\n                // must tolerate []'d groups in a content model in an element declaration\n                // also in data attribute specifications of attlist declaration\n                // also link type declaration subsets in linktype declarations\n                // also link attribute specification lists in link declarations\n                throw new Error(`unsupported '[' char in ${decltype} declaration`);\n            } else {\n                throw new Error(\"unexpected '[' char in declaration\");\n            }\n        } else {\n            throw new Error(`unexpected ${rawdata[j]} char in declaration`);\n        }\n        if (j < 0) {\n            return j;\n        }\n    }\n    return -1; // incomplete\n}\n```", "role": "assistant"}}], "created": 1687491494, "id": "chatcmpl-7URugX89PsD2GQlWHBuN8woJorsZa", "model": "gpt-3.5-turbo-0301", "object": "chat.completion", "usage": {"completion_tokens": 937, "prompt_tokens": 1001, "total_tokens": 1938}}, "timespan": 31.18789242208004, "error_msg": null}}